\documentclass[12pt]{report}
\usepackage{psu-thesis}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{amsmath,amsfonts,amssymb,textgreek,stmaryrd}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage[references]{agda}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{amsthm}
\usepackage{lmodern}
\usepackage[sort&compress,square,comma,numbers,longnamesfirst]{natbib}
\usepackage{semantic}
\usepackage[hang]{caption}
\usepackage{color}
\usepackage{tcolorbox}
\usepackage{comment}
\usepackage{textcomp}
\usepackage{dashbox}
\usepackage{lscape}
\usepackage{afterpage}
\usepackage{url}
\usepackage{listings}
\usepackage[normal]{subfigure}
\usepackage[all]{xy}
\usepackage{enumerate}
\usepackage[shortlabels]{enumitem}
\usepackage{makeidx}
\usepackage{hyperref}

\usepackage[subfigure]{tocloft}
\usepackage[titletoc]{appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\DeclareUnicodeCharacter{8759}{\ensuremath{::}}
\DeclareUnicodeCharacter{10218}{\guillemotleft}
\DeclareUnicodeCharacter{10219}{\guillemotright}

\newcommand{\cL}{{\cal L}}

\newcommand{\refsec}[1]{Section \ref{sec:#1}}
\newcommand{\AgdaData}[1]{\AgdaDatatype{#1}}
\newcommand{\AgdaCon}[1]{\AgdaInductiveConstructor{#1}}
\newcommand{\AgdaFun}[1]{\AgdaFunction{#1}}
\newcommand{\AgdaVar}[1]{\AgdaBound{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\contentsname}{Table of Contents}

\addtocontents{toc}{\protect\renewcommand{\protect\cftpartpresnum}{\partname\;}}
\addtocontents{toc}{\protect\renewcommand{\protect\cftchappresnum}{\chaptername\;}}
\setlength{\cftchapnumwidth}{\widthof{\sc\chaptername~00~~~}}

\makeindex

\definecolor{grey}{rgb}{0.8,0.8,0.8}
\definecolor{gray}{rgb}{0.57,0.57,0.57}

\setlist{partopsep=-3em}
\setlist{topsep=-3em}
\setlist{parsep=-2em}
\setlist{itemsep=-.2em}

\newcommand{\Fig}[1]{Figure~\ref{fig:#1}}

\newcommand{\cf}[0]{{cf.}}
\newcommand{\eg}[0]{{e.g.}}
\newcommand{\ie}[0]{{i.e.}}
\newcommand{\aka}[0]{{a.k.a.}}

\newtheorem{proposition}{Proposition}
\newtheorem*{proposition*}{Proposition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{conjecture}{Conjecture}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem{remark}{Remark}

\numberwithin{definition}{section}
\numberwithin{equation}{section}
\numberwithin{proposition}{section}
\numberwithin{conjecture}{section}
\numberwithin{theorem}{section}
\numberwithin{lemma}{section}
\numberwithin{corollary}{section}
\numberwithin{example}{section}
\numberwithin{remark}{section}


\newcommand{\Title}{Closed Universes for Generic Programming}

\begin{document}

\title{\Title}
\titleline{\Title}

\author{Larry Diehl}
\principaladviser{Tim Sheard}{\ }
\firstreader{James Hook}
\secondreader{Mark P. Jones}
\thirdreader{Andrew Tolmach}
\graduaterepresentative{Robert Bass}
\departmenthead{Warren Harrison}
\grantdate{January}{1}{2017}

\titlep
\prefatory
\prefacesection{Abstract}
\vskip-5.5ex
$~~~~~~$Abstract goes here.

\prefacesection{Dedication} 
Dedication goes here.

\prefacesection{Acknowledgments}
Acknowledgments go here.
\newpage

\afterpreface
\body

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\part{Prelude}\label{part:prelude}

\chapter{Introduction}\label{ch:intro}
\section{Dependently Typed Programming}
\section{Motivation}
\section{Thesis \& Contributions}
\section{Agda Conventions}

\chapter{Universes}\label{ch:univ}
\include{Thesis/Classifications}
\include{Thesis/Types}
\include{Thesis/Universes}
\include{Thesis/TypesAsUniverses}

\chapter{Closed Type Theory}\label{ch:univ}
\section{Total Programming}
\include{Thesis/GenericW}
\include{Thesis/ClosedW}
\section{Abstract \& Concrete Types}

\part{Open Algebraic Universes}\label{part:open}

\chapter{Open Algebraic Types}\label{ch:open}
\section{Dependent Types}
\section{Infinitary Types}
\section{Indexed Types}
\section{Inductive-Recursive Types}
\section{Indexed Inductive-Recursive Types}


%% %% Inductive \& Recursive Type Families
%% %% inductive introduces new inductiion principle, recursive derives
%% %% from IP of index
%% \chapter{Inductive \& Recursive Families}\label{ch:indrec}
%% \section{Inductive \& Recursive Families}
%% \section{Recursive Argument \& Return Families}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% %% Open Universe of Inductive Types
%% \part{Open Type Theory}\label{part:open}

%% %% spectrum of open type theory
%% %% get more closed by using `Desc

%% \chapter{Open Algebraic Datatypes}\label{ch:desc}
%% \section{Dependent Types}
%% %% start with Func, then specialize to mutual Args
%% %% List, Rose, and Term
%% \section{Indexed Types}
%% %% Vec, BigStep, ScopedTerm
%% %% show both constructor Vec and computational Vec
%% %% Algebraic = Inductve, Computational = Recursive
%% %% Algebraic Type Families vs Computational Type Families
%% %% vs Computational-Algebraic Type Families
%% %% PRE: Recursive-Inductive Families of Types
%% %% FINAL: Recursive-Inductive Families of Inductive-Recursive Types
%% \section{Inductive-Recursive Types}
%% %% Arith, Type
%% \section{Indexed Inductive-Recursive Types}
%% %% Norm

\chapter{Type Theory as a DSL}\label{ch:gelim}

%% syntatic = use less isomorphism transformations
%% generalized universe where meaning maps to something kinded Set1
\section{Syntactic versus Semantic Encodings}
\section{Generic Type Formers}
%% write example using anon pattern matching lambdas
%% then same example using only elims for pairs
\section{Generic Constructors}
\section{Generic Eliminators}
%% Hyps an example of domain supplement to ind

%% First chapter on regular generic-elim/Swedish
%% Second on index and parameter awareness
%% Third on `Desc codes with implicit args and FO \delta

%% OPEN generic example of lookup/update only at recursive positions
%% this should make index-preservation easy to state

%% data List (A : Set) : Set really module Foo (A : Set) data List : Set -> Set

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\part{Closed Algebraic Universes}\label{part:closed}

%% closed universe TT as DSL

%% maybe show how lookup/update cannot effectively work in open
%% universe for certain types, and maybe show closed univ elim
%% (extending elim to Type too)

%% generalized universe
%% not Uni (U : Set) (El : U -> Set)
%% but Uni (A : Set a) (B : Set b) (U : A) (El : U -> B) : suc (max a b)

\chapter{Closed Algebraic Types}\label{ch:closed}
\section{Closure under indexed W Types}
\section{Closure under indexed inductive-recursive $\mu$ Types}

\chapter{Generic Lookup \& Update}\label{ch:gupdate}
%% PropVecRose for needing inductive PathVec and update of type family
%% ConstantVecRose for update of infinitary value
\section{Generic Lookup}
\section{Generic Update}

%% combinator for congruence over restricted Desc (no Bool/Sum or
%% kappa), doing congruence for Type cases (GP tactical)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\part{Closed Hierarchy of Universes}\label{part:hier}

\chapter{Closed Hierarchy of W Universes}\label{ch:hier}
\chapter{Closed Hierarchy of $\mu$ Universes}\label{ch:hier}
\chapter{Generic Datatype Arguments}\label{ch:gargs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \part{Large Datatype Constructions}\label{part:large}

%% \chapter{Small Slice \& Family Equivalence}\label{ch:equiv}
%% \chapter{Large Induction-Recursion}\label{ch:largeir}
%% \chapter{Large Recursion-Induction}\label{ch:largeri}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \part{Irish Encodings}\label{part:irish}
%% \chapter{Irish Descriptions}\label{ch:irish}
%% \chapter{Description-Only Closed Universes}\label{ch:desconly}

%% Morris thesis distinguishes syntactic (concrete) prog from
%% semantic (generic) prog. this is bc container/w types (semantics)
%% are a large translation from from their declarations
%% IR is less of a translation, almost to the point that generic
%% prog is also syntactic (counterexample is Rec arg with Unit domain)
%% another way this thesis is different is closed universes
%% gelim `Desc shows how we can get more syntactic
%% truly syntactic GP using Irish IR, but not semantically understood
%% Generic semantic Swedish function has Unit codomains
%% also big translation of product or dis-union infinitary types
%% Generic Swedish also supports large IR, which W does not
%% But Irish still does not handle List (Rose A) translation
%% can always copy Desc of list into Rose, but then cant pass a List in
%% However Exp (Maybe A) does work with large RI

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\part{Postlude}\label{part:postlude}
\chapter{Inductive versus Recursive Families}\label{ch:ivsr}
%% when to use one over the other
\chapter{Related Work}\label{ch:related}
%% comparison with other Desc representations
%%   peter morris ``semantic'' vs ``syntatic''
%%   irish pushes towards syntatic from semantic
\chapter{Future Work}\label{ch:future}
\chapter{Conclusion}\label{ch:conc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \addtocontents{toc}{\protect\renewcommand{\protect\cftpartpresnum}{}}
%% \addtocontents{toc}{\protect\renewcommand{\protect\cftchappresnum}{}}
%% \clearpage
%% \phantomsection{}
%% \addcontentsline{toc}{part}{Bibliography}
%% \bibliographystyle{plainnat}
%% \bibliography{thesis}

%% \clearpage
%% \phantomsection
%% \addcontentsline{toc}{part}{Index}
%% {\small
%% \begin{singlespace}
%% \printindex
%% \end{singlespace}
%% }

%% \clearpage
%% \begin{appendices}
%% \include{appendix}
%% \end{appendices}

\end{document}

