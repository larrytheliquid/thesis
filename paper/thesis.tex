\documentclass[12pt]{report}
\usepackage{psu-thesis}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{amsmath,amsfonts,amssymb,textgreek,stmaryrd}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage[references]{agda}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{amsthm}
\usepackage{lmodern}
\usepackage[sort&compress,square,comma,numbers,longnamesfirst]{natbib}
\usepackage{semantic}
\usepackage[hang]{caption}
\usepackage{color}
\usepackage{tcolorbox}
\usepackage{comment}
\usepackage{textcomp}
\usepackage{dashbox}
\usepackage{lscape}
\usepackage{afterpage}
\usepackage{url}
\usepackage{listings}
\usepackage[normal]{subfigure}
\usepackage[all]{xy}
\usepackage{enumerate}
\usepackage[shortlabels]{enumitem}
\usepackage{makeidx}
\usepackage{hyperref}

\usepackage[subfigure]{tocloft}
\usepackage[titletoc]{appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\DeclareUnicodeCharacter{8759}{\ensuremath{::}}
\DeclareUnicodeCharacter{10218}{\guillemotleft}
\DeclareUnicodeCharacter{10219}{\guillemotright}
\DeclareUnicodeCharacter{956}{\ensuremath{\mu}}
%% \DeclareUnicodeCharacter{8729}{\ensuremath{\cdot}}
%% \DeclareUnicodeCharacter{94}{\ensuremath{foo}}

\newcommand{\anit}{\ensuremath{\alpha_\mathrm{init}}}
\newcommand{\inv}{\ensuremath{V}}

\newcommand{\nat}{\ensuremath{\mathbb{N}}}
\newcommand{\arr}{\ensuremath{\rightarrow}}
\newcommand{\set}{\mathrm{\mathbf{Set}}}
\newcommand{\dfn}[1]{\mathrm{\mathbf{#1}} \triangleq}
\newcommand{\tp}[1]{\mathrm{\mathbf{#1}}}
\newcommand{\stm}[1]{\mathrm{\mathbf{#1}}}

\newcommand{\refch}[1]{Chapter \ref{ch:#1}}
\newcommand{\refsec}[1]{Section \ref{sec:#1}}
\newcommand{\AgdaData}[1]{\AgdaDatatype{#1}}
\newcommand{\AgdaCon}[1]{\AgdaInductiveConstructor{#1}}
\newcommand{\AgdaFun}[1]{\AgdaFunction{#1}}
\newcommand{\AgdaVar}[1]{\AgdaBound{#1}}
\newcommand{\AgdaNum}[1]{\AgdaModule{#1}}

\newcommand{\AgdaBind}{\renewcommand{\AgdaPostulate}[1]
  {\AgdaNoSpaceMath{\AgdaFontStyle{\textcolor{AgdaBound}{\AgdaLink{##1}}}}}
}

\newcommand{\AgdaUnbind}{\renewcommand{\AgdaPostulate}[1]
  {\AgdaNoSpaceMath{\AgdaFontStyle{\textcolor{AgdaPostulate}{\AgdaLink{##1}}}}}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\contentsname}{Table of Contents}

\addtocontents{toc}{\protect\renewcommand{\protect\cftpartpresnum}{\partname\;}}
\addtocontents{toc}{\protect\renewcommand{\protect\cftchappresnum}{\chaptername\;}}
\setlength{\cftchapnumwidth}{\widthof{\sc\chaptername~00~~~}}

\makeindex

\definecolor{grey}{rgb}{0.8,0.8,0.8}
\definecolor{gray}{rgb}{0.57,0.57,0.57}

\setlist{partopsep=-3em}
\setlist{topsep=-3em}
\setlist{parsep=-2em}
\setlist{itemsep=-.2em}

\newcommand{\Fig}[1]{Figure~\ref{fig:#1}}

\newcommand{\cf}[0]{{cf.}}
\newcommand{\eg}[0]{{e.g.}}
\newcommand{\ie}[0]{{i.e.}}
\newcommand{\aka}[0]{{a.k.a.}}
\newcommand{\carot}{\string^}

\newtheorem{proposition}{Proposition}
\newtheorem*{proposition*}{Proposition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{conjecture}{Conjecture}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem{remark}{Remark}

\numberwithin{definition}{section}
\numberwithin{equation}{section}
\numberwithin{proposition}{section}
\numberwithin{conjecture}{section}
\numberwithin{theorem}{section}
\numberwithin{lemma}{section}
\numberwithin{corollary}{section}
\numberwithin{example}{section}
\numberwithin{remark}{section}


\newcommand{\Title}{Generic Programming over Inductive-Recursive Types and Closed Universes}

\begin{document}

\title{\Title}
\titleline{\Title}

\author{Larry Diehl}
\principaladviser{Tim Sheard}{\ }
\firstreader{James Hook}
\secondreader{Mark P. Jones}
\thirdreader{Andrew Tolmach}
\graduaterepresentative{Robert Bass}
\departmenthead{Warren Harrison}
\grantdate{March}{28}{2017}

\titlep
\prefatory
\prefacesection{Abstract}
\vskip-5.5ex
$~~~~~~$Abstract goes here.

\prefacesection{Dedication} 
Dedication goes here.

\prefacesection{Acknowledgments}
Acknowledgments go here.
\newpage

\afterpreface
\body

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\part{Prelude}\label{part:prelude}

\chapter{Introduction}\label{ch:intro}
\section{Dependently Typed Programming}
\section{Motivation}
\section{Thesis \& Contributions}
\section{Agda Conventions}

\chapter{Types \& Universes}\label{ch:univ}

A \textit{type} is a collection of values, and a \textit{universe} is
a collection of types (possibly closed under certain type formers).
In this section we review different classes of types (e.g. indexed
types, infinitary types, etc).
This allows us to be clear about what each class adds
to the express power of a language (i.e. what sorts of new values we
can construct.)

We also review properties of both types and universes
(e.g. inductiveness, openness, etc). These properties determine how we
can use values (i.e. what elimination principles are valid for them).
With a thorough understanding of classifications and
properties of types and universes, we can precisely describe which
classifications and properties we need to perform the main goal of
this thesis, \textit{generic programming} (\refch{generic}) within
\textit{closed type theory} (\refch{closedtt}).

\include{Thesis/Types}
\include{Thesis/Universes}

\chapter{Generic Programming}\label{ch:generic}

\textit{Generic programming} is the act of writing
functions that can be applied to values of a collection of types
(a \textit{universe}).
Given a collection of types, a \textit{generic function} can be
applied to values of any type in the collection. A
\textit{polymorphic function} universally
quantifies over some collection of values, and references an arbitrary
member of that collection in its type signature. Thefore, generic
functions are merely polymorphic functions.
The type of the quantified variable can be seen as the codes of the
universe, followed by the meaning function applied to a particular
code, followed by the remainder of the type signature.
$$
(\AgdaVar{x} : \AgdaFun{Code}) → \AgdaFun{Meaning}~\AgdaVar{x} → ...
$$

We have already seen many generic functions fitting this pattern in
\refsec{types} and \refsec{universes}. Below we reconsider some of
them, while classifying them by different forms of polymorphism. In
each of these examples, we emphasize the definition of
\AgdaFun{Code} (i.e. what the function is polymorphic over).

\include{Thesis/Poly}
\include{Thesis/Fully}
\include{Thesis/Total}


\chapter{Closed Type Theory}\label{ch:closedtt}

A \textit{closed type theory} is a dependently typed language with a
built-in collection of types
(i.e. \textit{primitives}) that will never be extended.
Such a type
theory can be modeled as a \textit{fully closed universe}. To qualify
as a closed type theory, we require that its collection of types is at
least closed under dependent function ($\Pi$) formation.

It is reasonable to assume that programming in a closed type theory
would be limiting, as programmers can only work with the types that
are built into the theory (compared to an \textit{open} theory where
users may \textit{extend} the language with custom types).
However, it turns out that a closed theory with an appropriate
collection of primitives can be used to \textit{model} any custom type
using only the primitives. Hence, instead of extending an open theory
with custom types using datatype declarations,
isomorphic versions of custom types
may be formed in a closed theory from its primitives.

Therefore, a closed type theory can model a dependently typed
programming language supporting custom types. Assume that we make
the universe model of such a theory algebraic, inductive, autonomous,
and concrete. This language supports
\textit{fully generic programming} (\refsec{fullygeneric}), allowing
programmers to write functions over all types of the
language, including custom types!
\footnote{By analogy, consider generic functions
  (like equality via \texttt{Eq} or comparison via \texttt{Ord})
  that a language like
  Haskell can derive for any appropriate type using the
  \texttt{deriving} keyword. While users of Haskell are limited to
  deriving the generic functions built into the compiler, users of
  such a closed type theory may write their own generic functions
  operating over any appropriate type.
}

\include{Thesis/ClosedW}

\part{Open Algebraic Universes}\label{part:open}

\chapter{Open Algebraic Types}\label{ch:open}

In \refsec{wtypes} we derived custom user-defined types as
\textit{well-founded trees}, or
\textit{well-orderings} (\AgdaData{W} types). \AgdaData{W} types
can be used to model
datatype declarations
in a \textit{closed type theory} (\refsec{wuni}),
without actually extending the metalanguage as done in
\textit{open type theory}. Unfortunately, \AgdaData{W} types are
inadequate (\refsec{inad}) models of first-order canonical terms, and
cannot be extended to support induction-recursion.

In this chapter we present an adequate alternative to modeling
datatype declarations, using \textit{algebraic semantics}. In
algebraic semantics a datatype is modeled as the \textit{fixpoint}
of a \textit{pattern functor}. We reify these two concepts as
datatypes to model them in type theory, where the type of fixpoints is
\AgdaData{μ} and the type of pattern functors is \AgdaData{Desc}.

This chapter begins with type-theoretic models of algebraic
non-dependent types, and progresses through a series of
extensions to model all the classes of types reviewed in
\refsec{types}. Finally, we restrict ourselves to deriving
user-defined types using algebraic semantics in
\textit{open type theory} (as is done in \refsec{wtypes} for
\AgdaData{W} types).
\refch{closed} covers how to use the
algebraic semantics presented in this chapter to instead derive
user-defined types in \textit{closed type theory} (as is done
in \refsec{wuni} for \AgdaData{W} types).

\include{Thesis/OpenAlg}
\include{Thesis/OpenInfAlg}
\include{Thesis/OpenDepAlg}
\include{Thesis/OpenIRAlg}
\include{Thesis/OpenIdxAlg}
\section{Indexed Inductive-Recursive Types}\label{sec:iiralg}



%% %% Inductive \& Recursive Type Families
%% %% inductive introduces new inductiion principle, recursive derives
%% %% from IP of index
%% \chapter{Inductive \& Recursive Families}\label{ch:indrec}
%% \section{Inductive \& Recursive Families}
%% \section{Recursive Argument \& Return Families}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% %% Open Universe of Inductive Types
%% \part{Open Type Theory}\label{part:open}

%% %% spectrum of open type theory
%% %% get more closed by using `Desc

%% \chapter{Open Algebraic Datatypes}\label{ch:desc}
%% \section{Dependent Types}
%% %% start with Func, then specialize to mutual Args
%% %% List, Rose, and Term
%% \section{Indexed Types}
%% %% Vec, BigStep, ScopedTerm
%% %% show both constructor Vec and computational Vec
%% %% Algebraic = Inductve, Computational = Recursive
%% %% Algebraic Type Families vs Computational Type Families
%% %% vs Computational-Algebraic Type Families
%% %% PRE: Recursive-Inductive Families of Types
%% %% FINAL: Recursive-Inductive Families of Inductive-Recursive Types
%% \section{Inductive-Recursive Types}
%% %% Arith, Type
%% \section{Indexed Inductive-Recursive Types}
%% %% Norm

\chapter{Type Theory as a DSL}\label{ch:gelim}

%% syntatic = use less isomorphism transformations
%% generalized universe where meaning maps to something kinded Set1
\section{Syntactic versus Semantic Encodings}
\section{Generic Type Formers}
%% write example using anon pattern matching lambdas
%% then same example using only elims for pairs
\section{Generic Constructors}
\section{Generic Eliminators}
%% Hyps an example of domain supplement to ind

%% First chapter on regular generic-elim/Swedish
%% Second on index and parameter awareness
%% Third on `Desc codes with implicit args and FO \delta

%% OPEN generic example of lookup/update only at recursive positions
%% this should make index-preservation easy to state

%% data List (A : Set) : Set really module Foo (A : Set) data List : Set -> Set

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\part{Closed Algebraic Universes}\label{part:closed}

%% closed universe TT as DSL

%% maybe show how lookup/update cannot effectively work in open
%% universe for certain types, and maybe show closed univ elim
%% (extending elim to Type too)

%% generalized universe
%% not Uni (U : Set) (El : U -> Set)
%% but Uni (A : Set a) (B : Set b) (U : A) (El : U -> B) : suc (max a b)

\chapter{Closed Algebraic Types}\label{ch:closed}
\section{Closure under indexed W Types}
\section{Closure under indexed inductive-recursive $\mu$ Types}

\chapter{Generic Lookup \& Update}\label{ch:gupdate}
%% PropVecRose for needing inductive PathVec and update of type family
%% ConstantVecRose for update of infinitary value
\section{Generic Lookup}
\section{Generic Update}

%% combinator for congruence over restricted Desc (no Bool/Sum or
%% kappa), doing congruence for Type cases (GP tactical)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\part{Closed Hierarchy of Universes}\label{part:hier}

\chapter{Closed Hierarchy of W Universes}\label{ch:hier}
\chapter{Closed Hierarchy of $\mu$ Universes}\label{ch:hier}
\chapter{Generic Datatype Arguments}\label{ch:gargs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \part{Large Datatype Constructions}\label{part:large}

%% \chapter{Small Slice \& Family Equivalence}\label{ch:equiv}
%% \chapter{Large Induction-Recursion}\label{ch:largeir}
%% \chapter{Large Recursion-Induction}\label{ch:largeri}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \part{Irish Encodings}\label{part:irish}
%% \chapter{Irish Descriptions}\label{ch:irish}
%% \chapter{Description-Only Closed Universes}\label{ch:desconly}

%% Morris thesis distinguishes syntactic (concrete) prog from
%% semantic (generic) prog. this is bc container/w types (semantics)
%% are a large translation from from their declarations
%% IR is less of a translation, almost to the point that generic
%% prog is also syntactic (counterexample is Rec arg with Unit domain)
%% another way this thesis is different is closed universes
%% gelim `Desc shows how we can get more syntactic
%% truly syntactic GP using Irish IR, but not semantically understood
%% Generic semantic Swedish function has Unit codomains
%% also big translation of product or dis-union infinitary types
%% Generic Swedish also supports large IR, which W does not
%% But Irish still does not handle List (Rose A) translation
%% can always copy Desc of list into Rose, but then cant pass a List in
%% However Exp (Maybe A) does work with large RI

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\part{Postlude}\label{part:postlude}
\chapter{Inductive versus Recursive Families}\label{ch:ivsr}
%% when to use one over the other
\chapter{Related Work}\label{ch:related}
%% comparison with other Desc representations
%%   peter morris ``semantic'' vs ``syntatic''
%%   irish pushes towards syntatic from semantic
\chapter{Future Work}\label{ch:future}
\chapter{Conclusion}\label{ch:conc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% \addtocontents{toc}{\protect\renewcommand{\protect\cftpartpresnum}{}}
%% \addtocontents{toc}{\protect\renewcommand{\protect\cftchappresnum}{}}
%% \clearpage
%% \phantomsection{}
%% \addcontentsline{toc}{part}{Bibliography}
%% \bibliographystyle{plainnat}
%% \bibliography{thesis}

%% \clearpage
%% \phantomsection
%% \addcontentsline{toc}{part}{Index}
%% {\small
%% \begin{singlespace}
%% \printindex
%% \end{singlespace}
%% }

%% \clearpage
%% \begin{appendices}
%% \include{appendix}
%% \end{appendices}

\end{document}

